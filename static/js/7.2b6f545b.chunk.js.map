{"version":3,"sources":["ui/components/Wallpaper/common/Wallpaper.tsx","ui/components/Wallpaper/common/random.ts","ui/components/Wallpaper/GameOfLife/Cell.ts","ui/components/Wallpaper/GameOfLife/Game.ts","ui/components/Wallpaper/GameOfLife/index.tsx"],"names":["CanvasWallpaper","props","draw","className","pixelated","canvasRef","useDrawingCanvas","classNames","undefined","push","join","ref","OffscreenCanvasWallpaper","initDrawingModule","useOffscreenDrawingCanvas","randomInt","from","to","Math","floor","random","randomRange","Cell","initiallyAlive","status","neighbors","this","neighbor","reduce","s","n","isAlive","Game","width","height","board","i","j","dx","dy","x","y","addNeighbor","ctx","save","fillStyle","fillRect","restore","forEach","row","cell","check","age","swap","widthPX","heightPX","setTransform","globalAlpha","game","clearRect","move","interval","setInterval","clearInterval","GameOfLife"],"mappings":"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","file":"static/js/7.2b6f545b.chunk.js","sourcesContent":["import React from 'react'\nimport useDrawingCanvas, { DrawingMethod } from 'react-hooks-use-drawing-canvas'\nimport { useOffscreenDrawingCanvas } from 'react-hooks-use-offscreen-drawing-canvas'\nimport './Wallpaper.css'\n\nexport type CanvasDrawingMethod = DrawingMethod\n\nexport const CanvasWallpaper: React.FC<{\n  /** extra classes for css */\n  className: string\n  draw: CanvasDrawingMethod\n  /** Render the canvas pixelated; without interpolation. Default: false */\n  pixelated?: boolean\n}> = props => {\n  const { draw, className, pixelated = false } = props\n  const canvasRef = useDrawingCanvas(draw)\n  const classNames = ['Wallpaper', 'Canvas']\n\n  if (className !== undefined) {\n    classNames.push(className)\n  }\n  if (pixelated) {\n    classNames.push('pixelated')\n  }\n\n  return <canvas className={classNames.join(' ')} ref={canvasRef} />\n}\n\nexport const OffscreenCanvasWallpaper: React.FC<{\n  /** extra classes for css */\n  className: string\n  initDrawingModule: () => Promise<typeof import('worker-loader!*')>\n  /** Render the canvas pixelated; without interpolation. Default: false */\n  pixelated?: boolean\n}> = props => {\n  const { className, initDrawingModule, pixelated } = props\n  const canvasRef = useOffscreenDrawingCanvas(initDrawingModule)\n  const classNames = ['Wallpaper', 'Canvas', 'Offscreen']\n\n  if (className !== undefined) {\n    classNames.push(className)\n  }\n  if (pixelated) {\n    classNames.push('pixelated')\n  }\n\n  return <canvas className={classNames.join(' ')} ref={canvasRef} />\n}\n","/**\n * Returns a random integer between two numbers, or if there is only one number,\n * between zero and that number.\n *\n * @param from The lower bound\n * @param to The upper bound\n */\nexport const randomInt = (from: number, to: number = from) => {\n  if (from === to) from = 0\n  return from + Math.floor(Math.random() * (to - from))\n}\n\n/**\n * Returns a random float in a given range.\n */\nexport const randomRange = (from: number, to: number) => {\n  return from + Math.random() * (to - from)\n}\n\n/** Returns a random normally distributed float */\nexport const randomNormal = (mean = 0, stddev = 1) => {\n  let u = 0\n  let v = 0\n  while (u === 0) u = Math.random()\n  while (v === 0) v = Math.random()\n  const statistic = Math.sqrt(-2 * Math.log(u)) + Math.cos(2 * Math.PI * v)\n  return statistic * stddev + mean\n}\n","export default class Cell {\n  private status: number\n  private neighbors: Cell[] = []\n\n  constructor(initiallyAlive: boolean) {\n    this.status = initiallyAlive ? 1 : 0\n  }\n\n  get isAlive() {\n    return this.status & 1\n  }\n\n  swap() {\n    this.status ^= 1\n  }\n\n  addNeighbor(neighbor: Cell) {\n    this.neighbors.push(neighbor)\n  }\n\n  check() {\n    const liveNeighbors = this.neighbors.reduce((s, n) => s + n.isAlive, 0)\n\n    if ((liveNeighbors | this.status) === 3) this.status |= 2\n  }\n\n  age() {\n    this.status = this.status >> 1\n  }\n}\n","import Cell from './Cell'\nimport { randomInt } from '../common/random'\n\nexport default class Game {\n  private width: number\n  private height: number\n  /**\n   * A cell is a number representing different states.\n   * The bits from least significan to most significant mean:\n   * - The cells current status.\n   * - The cells next status.\n   */\n  private board: Cell[][]\n\n  constructor(width: number, height: number) {\n    this.width = Math.floor(width)\n    this.height = Math.floor(height)\n    this.board = []\n\n    const probabilityOfLife = 0.1\n    for (let i = 0; i < this.width; i++) {\n      this.board[i] = []\n      for (let j = 0; j < this.height; j++) {\n        this.board[i][j] = new Cell(Math.random() < probabilityOfLife)\n      }\n    }\n\n    // addd the cell's neighbors\n    for (let i = 0; i < this.width; i++) {\n      for (let j = 0; j < this.height; j++) {\n        for (const [dx, dy] of [\n          [-1, -1],\n          [-1, 0],\n          [-1, 1],\n          [0, -1],\n          [0, 1],\n          [1, -1],\n          [1, 0],\n          [1, 1]\n        ]) {\n          const x = (i + dx + this.width) % this.width\n          const y = (j + dy + this.height) % this.height\n          this.board[i][j].addNeighbor(this.board[x][y])\n        }\n      }\n    }\n  }\n\n  draw(ctx: CanvasRenderingContext2D) {\n    for (let i = 0; i < this.width; i++) {\n      for (let j = 0; j < this.height; j++) {\n        if (this.board[i][j].isAlive) {\n          ctx.save()\n          ctx.fillStyle = `hsl(${randomInt(360)},100%,40%)`\n          ctx.fillRect(i, j, 1, 1)\n          ctx.restore()\n        }\n      }\n    }\n  }\n\n  move() {\n    this.board.forEach(row => row.forEach(cell => cell.check()))\n    this.board.forEach(row => row.forEach(cell => cell.age()))\n\n    const randomSwaps = 5\n    for (let i = 0; i < randomSwaps; i++) {\n      this.board[randomInt(this.width)][randomInt(this.height)].swap()\n    }\n  }\n}\n","import React from 'react'\nimport { CanvasWallpaper, CanvasDrawingMethod } from '../common/Wallpaper'\nimport Game from './Game'\n\nconst draw: CanvasDrawingMethod = (\n  ctx,\n  { width: widthPX, height: heightPX }\n) => {\n  // transform the canvas\n  const ratio = 4\n  const width = widthPX / ratio\n  const height = heightPX / ratio\n  ctx.setTransform(ratio, 0, 0, ratio, 0, 0)\n  ctx.globalAlpha = 0.2\n\n  const game = new Game(width, height)\n\n  const draw = () => {\n    ctx.clearRect(0, 0, width, height)\n\n    game.draw(ctx)\n    game.move()\n  }\n\n  const interval = setInterval(draw, 100)\n  return () => {\n    clearInterval(interval)\n  }\n}\n\nconst GameOfLife: React.FC = () => (\n  <CanvasWallpaper className=\"GameOfLife\" draw={draw} pixelated />\n)\n\nexport default GameOfLife\n"],"sourceRoot":""}