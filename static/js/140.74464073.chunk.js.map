{"version":3,"file":"static/js/140.74464073.chunk.js","mappings":"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","sources":["ui/components/Wallpaper/common/random.ts","ui/components/Wallpaper/YinYang/layer.ts","ui/components/Wallpaper/YinYang/index.tsx","ui/components/Wallpaper/common/react-hooks-use-drawing-canvas/index.ts","ui/components/Wallpaper/common/Wallpaper.tsx"],"sourcesContent":["/**\n * Returns a random integer between two numbers, or if there is only one number,\n * between zero and that number.\n *\n * @param from The lower bound\n * @param to The upper bound\n */\nexport const randomInt = (from: number, to: number = from) => {\n  if (from === to) from = 0\n  return from + Math.floor(Math.random() * (to - from))\n}\n\n/**\n * Returns a random float in a given range.\n */\nexport const randomRange = (from: number, to: number) => {\n  return from + Math.random() * (to - from)\n}\n\n/** Returns a random normally distributed float */\nexport const randomNormal = (mean = 0, stddev = 1) => {\n  let u = 0\n  let v = 0\n  while (u === 0) u = Math.random()\n  while (v === 0) v = Math.random()\n  const statistic = Math.sqrt(-2 * Math.log(u)) + Math.cos(2 * Math.PI * v)\n  return statistic * stddev + mean\n}\n","// by changing these factors, the pattern will evolve differently\nconst leftFactor = 1\nconst rightFactor = 1\n\nconst layer = (\n  ctx: CanvasRenderingContext2D,\n  radius: number,\n  angle: number,\n  primaryStyle: string | CanvasGradient | CanvasPattern,\n  secondaryStyle: string | CanvasGradient | CanvasPattern\n): void => {\n  // draw semicircles and go deeper\n  ctx.save()\n  ctx.rotate(angle)\n\n  // primary colour\n  ctx.beginPath()\n  ctx.arc(0, 0, radius, 0, Math.PI)\n  ctx.closePath()\n  ctx.fillStyle = primaryStyle\n  ctx.fill()\n\n  // secondary color\n  ctx.beginPath()\n  ctx.arc(0, 0, radius, 0, Math.PI, true)\n  ctx.closePath()\n  ctx.fillStyle = secondaryStyle\n  ctx.fill()\n\n  if (radius < 30) {\n    const half = radius / 2\n    // bigger circles\n    ctx.beginPath()\n    ctx.arc(-half, 0, half, 0, 2 * Math.PI)\n    ctx.closePath()\n\n    ctx.fillStyle = primaryStyle\n    ctx.fill()\n\n    ctx.beginPath()\n    ctx.arc(half, 0, half, 0, 2 * Math.PI)\n    ctx.closePath()\n\n    ctx.fillStyle = secondaryStyle\n    ctx.fill()\n\n    // small circles\n    ctx.beginPath()\n    ctx.arc(-half, 0, half / 2, 0, 2 * Math.PI)\n    ctx.closePath()\n\n    ctx.fillStyle = secondaryStyle\n    ctx.fill()\n\n    ctx.beginPath()\n    ctx.arc(half, 0, half / 2, 0, 2 * Math.PI)\n    ctx.closePath()\n\n    ctx.fillStyle = primaryStyle\n    ctx.fill()\n  } else {\n    ctx.translate(-radius / 2, 0)\n    layer(ctx, radius / 2, leftFactor * angle, primaryStyle, secondaryStyle)\n\n    ctx.translate(radius, 0)\n    layer(ctx, radius / 2, rightFactor * angle, primaryStyle, secondaryStyle)\n  }\n\n  ctx.restore()\n}\n\nexport default layer\n","import React from 'react'\nimport { CanvasWallpaper, CanvasDrawingMethod } from '../common/Wallpaper'\nimport { randomInt } from '../common/random'\nimport layer from './layer'\n\nconst draw: CanvasDrawingMethod = (ctx, { width, height }) => {\n  const radius = Math.max(20, Math.min(width / 2, height / 2) - 20)\n\n  ctx.translate(width / 2, height / 2)\n\n  let hue = randomInt(0, 360)\n  let angle = 0\n\n  let frame: number\n  const drawFrame = () => {\n    frame = requestAnimationFrame(drawFrame)\n    ctx.clearRect(-width / 2, -height / 2, width, height)\n    const primaryStyle = `hsl(${hue},100%,40%)`\n    const secondaryStyle = `hsl(${hue + 180}, 100%,40%)`\n    layer(ctx, radius, angle, primaryStyle, secondaryStyle)\n\n    ctx.save()\n    ctx.beginPath()\n    ctx.arc(0, 0, radius, 0, 2 * Math.PI)\n    ctx.closePath()\n    ctx.fillStyle = 'rgba(255,255,255,0.45)'\n    ctx.fill()\n    ctx.restore()\n\n    hue = (hue + 0.2) % 360\n    angle = angle + 0.005\n  }\n\n  drawFrame()\n\n  return () => cancelAnimationFrame(frame)\n}\n\nconst YinYang: React.FC = () => {\n  return <CanvasWallpaper className=\"YinYang\" draw={draw} />\n}\n\nexport default YinYang\n","import {\n  MutableRefObject,\n  useEffect,\n  useLayoutEffect,\n  useRef,\n  useState\n} from 'react'\n\nexport type DrawingMethod = (\n  /** A 2d context on the referenced canvas */\n  context: CanvasRenderingContext2D,\n  /** Some properties about the canvas that may or may not be critical to the\n   * way the method is used.\n   */\n  props: {\n    /** The width of the context */\n    width: number\n    /** The height of the context */\n    height: number\n    /**\n     * A flag that tells the drawing method about the user's motion preferences.\n     * Perhaps a drawing method that has excessive movement would include a case\n     * for users that prefer reduced motion. Defaults to reduced motion.\n     */\n    prefersReducedMotion: boolean\n  }\n) => void | (() => void)\n\n/**\n * Provides the width and height of a referenced canvas in the dom.\n *\n * ***Note:*** this method assumes the width and height of the canvas will not\n * change unless the window width has changed.\n *\n * @param canvasRef A reference to the canvas element.\n */\nfunction useCanvasSize(\n  canvasRef: MutableRefObject<HTMLCanvasElement | undefined>\n) {\n  const [size, setSize] = useState({ width: 0, height: 0 })\n\n  useEffect(() => {\n    const getSize = () => {\n      if (!canvasRef.current) return\n      const dpr = window.devicePixelRatio\n      const width = canvasRef.current.offsetWidth * dpr\n      const height = canvasRef.current.offsetHeight * dpr\n      setSize({ width, height })\n    }\n    getSize()\n    window.addEventListener('resize', getSize)\n    return () => window.removeEventListener('resize', getSize)\n  }, [canvasRef])\n\n  return size\n}\n\n/**\n * A wrapper that will debounce the drawing method and call the drawing method\n * asynchronously.\n *\n * @param draw A closure that calls the drawing method with the intended props.\n * @param time The time to debounce in milliseconds.\n */\nconst debounceDraw = (\n  draw: () => void | (() => void),\n  time: number\n): (() => void) => {\n  let canceled = false\n  let cleanUp: void | (() => void)\n\n  const timeout = setTimeout(async () => {\n    if (!canceled) {\n      cleanUp = draw()\n    }\n  }, time)\n\n  return () => {\n    // cancel the timeout\n    clearTimeout(timeout)\n    // set the canceled flag\n    canceled = true\n    if (cleanUp) {\n      cleanUp\n    }\n  }\n}\n\n/**\n * Provides an api for getting a 2d context from a canvas element.\n *\n * The returned reference should be assigned to a canvas element. The drawing\n * method will then be called with a context on the referenced canvas.\n *\n * Be careful about defining the drawing method. If it is defined inline, then\n * it will be re-called on every render.\n *\n * ```ts\n * // defines a new drawing function on every render\n * const Component = () => {\n *   const canvasRef = useDrawingCanvas(ctx => ctx.fillRect(0, 0, 10, 10))\n *\n *   return <canvas ref={canvasRef} />\n * }\n *\n * // safer\n * const draw = ctx => ctx.fillRect(0, 0, 10, 10)\n *\n * const Component = () => {\n *   const canvasRef = useDrawingCanvas(draw)\n *\n *   return <canvas ref={canvasRef} />\n * }\n * ```\n *\n * @param draw The drawing method\n */\nexport default function useDrawingCanvas(draw: DrawingMethod) {\n  const ref = useRef<HTMLCanvasElement>()\n  const [context, setContext] = useState<CanvasRenderingContext2D>()\n  const { width, height } = useCanvasSize(ref)\n\n  useEffect(() => {\n    if (!ref.current) return\n\n    setContext(ref.current.getContext('2d') || undefined)\n  }, [ref])\n\n  useLayoutEffect(() => {\n    if (context) {\n      context.canvas.width = width\n      context.canvas.height = height\n\n      return debounceDraw(\n        () =>\n          draw(context, {\n            width,\n            height,\n            prefersReducedMotion: !window.matchMedia(\n              '(prefers-reduced-motion: no-preferece)'\n            ).matches\n          }),\n        50\n      )\n    }\n  }, [draw, context, width, height])\n\n  return ref\n}\n","import React, { MutableRefObject } from 'react'\nimport useDrawingCanvas, {\n  DrawingMethod\n} from './react-hooks-use-drawing-canvas'\nimport './Wallpaper.css'\n\nexport type CanvasDrawingMethod = DrawingMethod\n\nexport const CanvasWallpaper: React.FC<{\n  /** extra classes for css */\n  className: string\n  draw: CanvasDrawingMethod\n  /** Render the canvas pixelated; without interpolation. Default: false */\n  pixelated?: boolean\n}> = props => {\n  const { draw, className, pixelated = false } = props\n  const canvasRef = useDrawingCanvas(draw)\n  const classNames = ['Wallpaper', 'Canvas']\n\n  if (className !== undefined) {\n    classNames.push(className)\n  }\n  if (pixelated) {\n    classNames.push('pixelated')\n  }\n\n  return (\n    <canvas\n      className={classNames.join(' ')}\n      ref={canvasRef as MutableRefObject<HTMLCanvasElement>}\n    />\n  )\n}\n"],"names":["randomInt","from","to","arguments","length","undefined","Math","floor","random","randomRange","layer","ctx","radius","angle","primaryStyle","secondaryStyle","save","rotate","beginPath","arc","PI","closePath","fillStyle","fill","half","translate","restore","draw","_ref","width","height","max","min","frame","hue","drawFrame","requestAnimationFrame","clearRect","cancelAnimationFrame","YinYang","_jsx","CanvasWallpaper","className","useDrawingCanvas","ref","useRef","context","setContext","useState","canvasRef","size","setSize","useEffect","getSize","current","dpr","window","devicePixelRatio","offsetWidth","offsetHeight","addEventListener","removeEventListener","useCanvasSize","getContext","useLayoutEffect","canvas","debounceDraw","time","cleanUp","canceled","timeout","setTimeout","async","clearTimeout","prefersReducedMotion","matchMedia","matches","props","pixelated","classNames","push","join"],"sourceRoot":""}