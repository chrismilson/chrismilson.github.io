{"version":3,"sources":["ui/components/Wallpaper/common/random.ts","../node_modules/react-hooks-use-canvas-size/lib/index.es.js","../node_modules/react-hooks-use-drawing-canvas/lib/index.es.js","ui/components/Wallpaper/common/Wallpaper.tsx","ui/components/Wallpaper/YinYang/layer.ts","ui/components/Wallpaper/YinYang/index.tsx"],"names":["randomInt","from","to","Math","floor","random","randomRange","useCanvasSize","canvasRef","useState","width","height","size","setSize","useEffect","current","getSize","offsetWidth","offsetHeight","window","addEventListener","removeEventListener","useDrawingCanvas","draw","ref","useRef","context","setContext","getContext","useLayoutEffect","canvas","prefersReducedMotion","matchMedia","matches","CanvasWallpaper","props","className","pixelated","classNames","undefined","push","join","layer","ctx","radius","angle","primaryStyle","secondaryStyle","save","rotate","beginPath","arc","PI","closePath","fillStyle","fill","half","translate","restore","max","min","frame","hue","drawFrame","requestAnimationFrame","clearRect","fillRect","cancelAnimationFrame","YinYang"],"mappings":"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","file":"static/js/9.50bf7e5a.chunk.js","sourcesContent":["/**\n * Returns a random integer between two numbers, or if there is only one number,\n * between zero and that number.\n *\n * @param from The lower bound\n * @param to The upper bound\n */\nexport const randomInt = (from: number, to: number = from) => {\n  if (from === to) from = 0\n  return from + Math.floor(Math.random() * (to - from))\n}\n\n/**\n * Returns a random float in a given range.\n */\nexport const randomRange = (from: number, to: number) => {\n  return from + Math.random() * (to - from)\n}\n\n/** Returns a random normally distributed float */\nexport const randomNormal = (mean = 0, stddev = 1) => {\n  let u = 0\n  let v = 0\n  while (u === 0) u = Math.random()\n  while (v === 0) v = Math.random()\n  const statistic = Math.sqrt(-2 * Math.log(u)) + Math.cos(2 * Math.PI * v)\n  return statistic * stddev + mean\n}\n","import { useState, useEffect } from 'react';\n\n/**\r\n * Provides the width and height of a referenced canvas in the dom.\r\n *\r\n * ***Note:*** this method assumes the width and height of the canvas will not\r\n * change unless the window width has changed.\r\n *\r\n * @param canvasRef A reference to the canvas element.\r\n */\r\nfunction useCanvasSize(canvasRef) {\r\n    const [size, setSize] = useState({ width: 0, height: 0 });\r\n    useEffect(() => {\r\n        if (!canvasRef.current)\r\n            return;\r\n        const getSize = () => {\r\n            const width = canvasRef.current.offsetWidth;\r\n            const height = canvasRef.current.offsetHeight;\r\n            setSize({ width, height });\r\n        };\r\n        getSize();\r\n        window.addEventListener('resize', getSize);\r\n        return () => window.removeEventListener('resize', getSize);\r\n    }, [canvasRef]);\r\n    return size;\r\n}\n\nexport default useCanvasSize;\n","import { useRef, useState, useEffect, useLayoutEffect } from 'react';\nimport useCanvasSize from 'react-hooks-use-canvas-size';\n\n/**\r\n * Provides an api for getting a 2d context from a canvas element.\r\n *\r\n * The returned reference should be assigned to a canvas element. The drawing\r\n * method will then be called with a context on the referenced canvas.\r\n *\r\n * Be careful about defining the drawing method. If it is defined inline, then\r\n * it will be re-called on every render.\r\n *\r\n * ```ts\r\n * // defines a new drawing function on every render\r\n * const Component = () => {\r\n *   const canvasRef = useDrawingCanvas(ctx => ctx.fillRect(0, 0, 10, 10))\r\n *\r\n *   return <canvas ref={canvasRef} />\r\n * }\r\n *\r\n * // safer\r\n * const draw = ctx => ctx.fillRect(0, 0, 10, 10)\r\n *\r\n * const Component = () => {\r\n *   const canvasRef = useDrawingCanvas(draw)\r\n *\r\n *   return <canvas ref={canvasRef} />\r\n * }\r\n * ```\r\n *\r\n * @param draw The drawing method\r\n */\r\nfunction useDrawingCanvas(draw) {\r\n    const ref = useRef();\r\n    const [context, setContext] = useState();\r\n    const { width, height } = useCanvasSize(ref);\r\n    useEffect(() => {\r\n        if (!ref.current)\r\n            return;\r\n        setContext(ref.current.getContext('2d'));\r\n    }, [ref]);\r\n    useLayoutEffect(() => {\r\n        if (context) {\r\n            context.canvas.width = width;\r\n            context.canvas.height = height;\r\n            return draw(context, {\r\n                width,\r\n                height,\r\n                prefersReducedMotion: !window.matchMedia('(prefers-reduced-motion: no-preferece)').matches\r\n            });\r\n        }\r\n    }, [draw, context, width, height]);\r\n    return ref;\r\n}\n\nexport default useDrawingCanvas;\n","import React from 'react'\nimport useDrawingCanvas, { DrawingMethod } from 'react-hooks-use-drawing-canvas'\nimport './Wallpaper.css'\n\nexport type CanvasDrawingMethod = DrawingMethod\n\nexport const CanvasWallpaper: React.FC<{\n  /** extra classes for css */\n  className: string\n  draw: CanvasDrawingMethod\n  /** Render the canvas pixelated; without interpolation. Default: false */\n  pixelated?: boolean\n}> = props => {\n  const { draw, className, pixelated = false } = props\n  const canvasRef = useDrawingCanvas(draw)\n  const classNames = ['Wallpaper', 'Canvas']\n\n  if (className !== undefined) {\n    classNames.push(className)\n  }\n  if (pixelated) {\n    classNames.push('pixelated')\n  }\n\n  return <canvas className={classNames.join(' ')} ref={canvasRef} />\n}\n","// by changing these factors, the pattern will evolve differently\nconst leftFactor = 1\nconst rightFactor = 1\n\nconst layer = (\n  ctx: CanvasRenderingContext2D,\n  radius: number,\n  angle: number,\n  primaryStyle: string | CanvasGradient | CanvasPattern,\n  secondaryStyle: string | CanvasGradient | CanvasPattern\n) => {\n  // draw semicircles and go deeper\n  ctx.save()\n  ctx.rotate(angle)\n\n  // primary colour\n  ctx.beginPath()\n  ctx.arc(0, 0, radius, 0, Math.PI)\n  ctx.closePath()\n  ctx.fillStyle = primaryStyle\n  ctx.fill()\n\n  // secondary color\n  ctx.beginPath()\n  ctx.arc(0, 0, radius, 0, Math.PI, true)\n  ctx.closePath()\n  ctx.fillStyle = secondaryStyle\n  ctx.fill()\n\n  if (radius < 30) {\n    const half = radius / 2\n    // bigger circles\n    ctx.beginPath()\n    ctx.arc(-half, 0, half, 0, 2 * Math.PI)\n    ctx.closePath()\n\n    ctx.fillStyle = primaryStyle\n    ctx.fill()\n\n    ctx.beginPath()\n    ctx.arc(half, 0, half, 0, 2 * Math.PI)\n    ctx.closePath()\n\n    ctx.fillStyle = secondaryStyle\n    ctx.fill()\n\n    // small circles\n    ctx.beginPath()\n    ctx.arc(-half, 0, half / 2, 0, 2 * Math.PI)\n    ctx.closePath()\n\n    ctx.fillStyle = secondaryStyle\n    ctx.fill()\n\n    ctx.beginPath()\n    ctx.arc(half, 0, half / 2, 0, 2 * Math.PI)\n    ctx.closePath()\n\n    ctx.fillStyle = primaryStyle\n    ctx.fill()\n  } else {\n    ctx.translate(-radius / 2, 0)\n    layer(ctx, radius / 2, leftFactor * angle, primaryStyle, secondaryStyle)\n\n    ctx.translate(radius, 0)\n    layer(ctx, radius / 2, rightFactor * angle, primaryStyle, secondaryStyle)\n  }\n\n  ctx.restore()\n}\n\nexport default layer\n","import React from 'react'\nimport { CanvasWallpaper, CanvasDrawingMethod } from '../common/Wallpaper'\nimport { randomInt } from '../common/random'\nimport layer from './layer'\n\nconst draw: CanvasDrawingMethod = (ctx, { width, height }) => {\n  const radius = Math.max(20, Math.min(width / 2, height / 2) - 20)\n\n  ctx.translate(width / 2, height / 2)\n\n  let hue = randomInt(0, 360)\n  let angle = 0\n\n  let frame: number\n  const drawFrame = () => {\n    frame = requestAnimationFrame(drawFrame)\n    ctx.clearRect(-width / 2, -height / 2, width, height)\n    const primaryStyle = `hsl(${hue},100%,40%)`\n    const secondaryStyle = `hsl(${hue + 180}, 100%,40%)`\n    layer(ctx, radius, angle, primaryStyle, secondaryStyle)\n    ctx.save()\n    ctx.fillStyle = 'rgba(255,255,255,0.5)'\n    ctx.fillRect(-width / 2, -height / 2, width, height)\n    ctx.restore()\n    hue = (hue + 0.2) % 360\n    angle = angle + 0.005\n  }\n\n  drawFrame()\n\n  return () => cancelAnimationFrame(frame)\n}\n\nconst YinYang: React.FC = () => {\n  return <CanvasWallpaper className=\"Perspectives\" draw={draw} />\n}\n\nexport default YinYang\n"],"sourceRoot":""}