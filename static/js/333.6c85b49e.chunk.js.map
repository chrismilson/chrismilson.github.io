{"version":3,"file":"static/js/333.6c85b49e.chunk.js","mappings":"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","sources":["ui/components/Wallpaper/common/random.ts","ui/components/Wallpaper/common/react-hooks-use-drawing-canvas/index.ts","ui/components/Wallpaper/common/Wallpaper.tsx","ui/components/Wallpaper/Perspectives/index.tsx"],"sourcesContent":["/**\n * Returns a random integer between two numbers, or if there is only one number,\n * between zero and that number.\n *\n * @param from The lower bound\n * @param to The upper bound\n */\nexport const randomInt = (from: number, to: number = from) => {\n  if (from === to) from = 0\n  return from + Math.floor(Math.random() * (to - from))\n}\n\n/**\n * Returns a random float in a given range.\n */\nexport const randomRange = (from: number, to: number) => {\n  return from + Math.random() * (to - from)\n}\n\n/** Returns a random normally distributed float */\nexport const randomNormal = (mean = 0, stddev = 1) => {\n  let u = 0\n  let v = 0\n  while (u === 0) u = Math.random()\n  while (v === 0) v = Math.random()\n  const statistic = Math.sqrt(-2 * Math.log(u)) + Math.cos(2 * Math.PI * v)\n  return statistic * stddev + mean\n}\n","import {\n  MutableRefObject,\n  useEffect,\n  useLayoutEffect,\n  useRef,\n  useState\n} from 'react'\n\nexport type DrawingMethod = (\n  /** A 2d context on the referenced canvas */\n  context: CanvasRenderingContext2D,\n  /** Some properties about the canvas that may or may not be critical to the\n   * way the method is used.\n   */\n  props: {\n    /** The width of the context */\n    width: number\n    /** The height of the context */\n    height: number\n    /**\n     * A flag that tells the drawing method about the user's motion preferences.\n     * Perhaps a drawing method that has excessive movement would include a case\n     * for users that prefer reduced motion. Defaults to reduced motion.\n     */\n    prefersReducedMotion: boolean\n  }\n) => void | (() => void)\n\n/**\n * Provides the width and height of a referenced canvas in the dom.\n *\n * ***Note:*** this method assumes the width and height of the canvas will not\n * change unless the window width has changed.\n *\n * @param canvasRef A reference to the canvas element.\n */\nfunction useCanvasSize(\n  canvasRef: MutableRefObject<HTMLCanvasElement | undefined>\n) {\n  const [size, setSize] = useState({ width: 0, height: 0 })\n\n  useEffect(() => {\n    const getSize = () => {\n      if (!canvasRef.current) return\n      const dpr = window.devicePixelRatio\n      const width = canvasRef.current.offsetWidth * dpr\n      const height = canvasRef.current.offsetHeight * dpr\n      setSize({ width, height })\n    }\n    getSize()\n    window.addEventListener('resize', getSize)\n    return () => window.removeEventListener('resize', getSize)\n  }, [canvasRef])\n\n  return size\n}\n\n/**\n * A wrapper that will debounce the drawing method and call the drawing method\n * asynchronously.\n *\n * @param draw A closure that calls the drawing method with the intended props.\n * @param time The time to debounce in milliseconds.\n */\nconst debounceDraw = (\n  draw: () => void | (() => void),\n  time: number\n): (() => void) => {\n  let canceled = false\n  let cleanUp: void | (() => void)\n\n  const timeout = setTimeout(async () => {\n    if (!canceled) {\n      cleanUp = draw()\n    }\n  }, time)\n\n  return () => {\n    // cancel the timeout\n    clearTimeout(timeout)\n    // set the canceled flag\n    canceled = true\n    if (cleanUp) {\n      cleanUp\n    }\n  }\n}\n\n/**\n * Provides an api for getting a 2d context from a canvas element.\n *\n * The returned reference should be assigned to a canvas element. The drawing\n * method will then be called with a context on the referenced canvas.\n *\n * Be careful about defining the drawing method. If it is defined inline, then\n * it will be re-called on every render.\n *\n * ```ts\n * // defines a new drawing function on every render\n * const Component = () => {\n *   const canvasRef = useDrawingCanvas(ctx => ctx.fillRect(0, 0, 10, 10))\n *\n *   return <canvas ref={canvasRef} />\n * }\n *\n * // safer\n * const draw = ctx => ctx.fillRect(0, 0, 10, 10)\n *\n * const Component = () => {\n *   const canvasRef = useDrawingCanvas(draw)\n *\n *   return <canvas ref={canvasRef} />\n * }\n * ```\n *\n * @param draw The drawing method\n */\nexport default function useDrawingCanvas(draw: DrawingMethod) {\n  const ref = useRef<HTMLCanvasElement>()\n  const [context, setContext] = useState<CanvasRenderingContext2D>()\n  const { width, height } = useCanvasSize(ref)\n\n  useEffect(() => {\n    if (!ref.current) return\n\n    setContext(ref.current.getContext('2d') || undefined)\n  }, [ref])\n\n  useLayoutEffect(() => {\n    if (context) {\n      context.canvas.width = width\n      context.canvas.height = height\n\n      return debounceDraw(\n        () =>\n          draw(context, {\n            width,\n            height,\n            prefersReducedMotion: !window.matchMedia(\n              '(prefers-reduced-motion: no-preferece)'\n            ).matches\n          }),\n        50\n      )\n    }\n  }, [draw, context, width, height])\n\n  return ref\n}\n","import React, { MutableRefObject } from 'react'\nimport useDrawingCanvas, {\n  DrawingMethod\n} from './react-hooks-use-drawing-canvas'\nimport './Wallpaper.css'\n\nexport type CanvasDrawingMethod = DrawingMethod\n\nexport const CanvasWallpaper: React.FC<{\n  /** extra classes for css */\n  className: string\n  draw: CanvasDrawingMethod\n  /** Render the canvas pixelated; without interpolation. Default: false */\n  pixelated?: boolean\n}> = props => {\n  const { draw, className, pixelated = false } = props\n  const canvasRef = useDrawingCanvas(draw)\n  const classNames = ['Wallpaper', 'Canvas']\n\n  if (className !== undefined) {\n    classNames.push(className)\n  }\n  if (pixelated) {\n    classNames.push('pixelated')\n  }\n\n  return (\n    <canvas\n      className={classNames.join(' ')}\n      ref={canvasRef as MutableRefObject<HTMLCanvasElement>}\n    />\n  )\n}\n","import React from 'react'\nimport { CanvasWallpaper, CanvasDrawingMethod } from '../common/Wallpaper'\nimport { randomInt } from '../common/random'\n\n/** Project a line of a set length from a point */\nconst project = (\n  ctx: CanvasRenderingContext2D,\n  from: { x: number; y: number },\n  to: { x: number; y: number },\n  length: number\n) => {\n  ctx.save()\n  ctx.translate(from.x, from.y)\n  ctx.moveTo(0, 0)\n  ctx.rotate(-Math.atan2(to.x - from.x, to.y - from.y))\n  ctx.lineTo(0, length)\n  ctx.restore()\n}\n\nconst draw: CanvasDrawingMethod = (ctx, { width, height }) => {\n  if (width < height) {\n    // portrait! rotate.\n    const temp = width\n    width = height\n    height = temp\n    ctx.setTransform(0, 1, 1, 0, 0, 0)\n  }\n\n  const centers = [\n    {\n      x: 0,\n      y: height / 4\n    },\n    {\n      x: width,\n      y: (3 * height) / 4\n    }\n  ]\n\n  const speed = 0.3\n  const separation = 30\n  const length = -width / 7\n  const lines = [\n    {\n      x: (2 * width) / 9,\n      offset: 0,\n      increment: speed,\n      separation,\n      length\n    },\n    {\n      x: (7 * width) / 9,\n      offset: 0,\n      increment: -2 * speed,\n      separation,\n      length\n    }\n  ]\n  let hue = randomInt(360)\n\n  let frame: number\n\n  ctx.lineWidth = 3\n  ctx.lineCap = 'round'\n\n  const drawFrame = () => {\n    frame = requestAnimationFrame(drawFrame)\n    ctx.clearRect(0, 0, width, height)\n    ctx.strokeStyle = `hsla(${hue++}, 100%, 40%, 0.6)`\n\n    ctx.beginPath()\n    lines.forEach(({ x, offset, separation, length }) => {\n      centers.forEach(center => {\n        for (\n          let y = offset - separation;\n          y < height + separation;\n          y += separation\n        ) {\n          project(ctx, { x, y }, center, length)\n        }\n      })\n    })\n    ctx.closePath()\n    ctx.stroke()\n    lines.forEach(line => {\n      line.offset = (line.offset + line.increment) % line.separation\n    })\n  }\n\n  drawFrame()\n\n  return () => cancelAnimationFrame(frame)\n}\n\nconst Perspectives: React.FC = () => {\n  return <CanvasWallpaper className=\"Perspectives\" draw={draw} />\n}\n\nexport default Perspectives\n"],"names":["randomInt","from","to","arguments","length","undefined","Math","floor","random","randomRange","useDrawingCanvas","draw","ref","useRef","context","setContext","useState","width","height","canvasRef","size","setSize","useEffect","getSize","current","dpr","window","devicePixelRatio","offsetWidth","offsetHeight","addEventListener","removeEventListener","useCanvasSize","getContext","useLayoutEffect","canvas","debounceDraw","time","cleanUp","canceled","timeout","setTimeout","async","clearTimeout","prefersReducedMotion","matchMedia","matches","CanvasWallpaper","props","className","pixelated","classNames","push","_jsx","join","project","ctx","save","translate","x","y","moveTo","rotate","atan2","lineTo","restore","_ref","temp","setTransform","centers","lines","offset","increment","separation","frame","hue","lineWidth","lineCap","drawFrame","requestAnimationFrame","clearRect","strokeStyle","beginPath","forEach","_ref2","center","closePath","stroke","line","cancelAnimationFrame","Perspectives"],"sourceRoot":""}