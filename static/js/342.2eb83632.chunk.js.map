{"version":3,"file":"static/js/342.2eb83632.chunk.js","mappings":"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","sources":["ui/components/Wallpaper/common/random.ts","ui/components/Wallpaper/common/react-hooks-use-drawing-canvas/index.ts","ui/components/Wallpaper/common/Wallpaper.tsx","ui/components/Wallpaper/GameOfLife/Cell.ts","ui/components/Wallpaper/GameOfLife/Game.ts","ui/components/Wallpaper/GameOfLife/index.tsx"],"sourcesContent":["/**\n * Returns a random integer between two numbers, or if there is only one number,\n * between zero and that number.\n *\n * @param from The lower bound\n * @param to The upper bound\n */\nexport const randomInt = (from: number, to: number = from) => {\n  if (from === to) from = 0\n  return from + Math.floor(Math.random() * (to - from))\n}\n\n/**\n * Returns a random float in a given range.\n */\nexport const randomRange = (from: number, to: number) => {\n  return from + Math.random() * (to - from)\n}\n\n/** Returns a random normally distributed float */\nexport const randomNormal = (mean = 0, stddev = 1) => {\n  let u = 0\n  let v = 0\n  while (u === 0) u = Math.random()\n  while (v === 0) v = Math.random()\n  const statistic = Math.sqrt(-2 * Math.log(u)) + Math.cos(2 * Math.PI * v)\n  return statistic * stddev + mean\n}\n","import {\n  MutableRefObject,\n  useEffect,\n  useLayoutEffect,\n  useRef,\n  useState\n} from 'react'\n\nexport type DrawingMethod = (\n  /** A 2d context on the referenced canvas */\n  context: CanvasRenderingContext2D,\n  /** Some properties about the canvas that may or may not be critical to the\n   * way the method is used.\n   */\n  props: {\n    /** The width of the context */\n    width: number\n    /** The height of the context */\n    height: number\n    /**\n     * A flag that tells the drawing method about the user's motion preferences.\n     * Perhaps a drawing method that has excessive movement would include a case\n     * for users that prefer reduced motion. Defaults to reduced motion.\n     */\n    prefersReducedMotion: boolean\n  }\n) => void | (() => void)\n\n/**\n * Provides the width and height of a referenced canvas in the dom.\n *\n * ***Note:*** this method assumes the width and height of the canvas will not\n * change unless the window width has changed.\n *\n * @param canvasRef A reference to the canvas element.\n */\nfunction useCanvasSize(\n  canvasRef: MutableRefObject<HTMLCanvasElement | undefined>\n) {\n  const [size, setSize] = useState({ width: 0, height: 0 })\n\n  useEffect(() => {\n    const getSize = () => {\n      if (!canvasRef.current) return\n      const dpr = window.devicePixelRatio\n      const width = canvasRef.current.offsetWidth * dpr\n      const height = canvasRef.current.offsetHeight * dpr\n      setSize({ width, height })\n    }\n    getSize()\n    window.addEventListener('resize', getSize)\n    return () => window.removeEventListener('resize', getSize)\n  }, [canvasRef])\n\n  return size\n}\n\n/**\n * A wrapper that will debounce the drawing method and call the drawing method\n * asynchronously.\n *\n * @param draw A closure that calls the drawing method with the intended props.\n * @param time The time to debounce in milliseconds.\n */\nconst debounceDraw = (\n  draw: () => void | (() => void),\n  time: number\n): (() => void) => {\n  let canceled = false\n  let cleanUp: void | (() => void)\n\n  const timeout = setTimeout(async () => {\n    if (!canceled) {\n      cleanUp = draw()\n    }\n  }, time)\n\n  return () => {\n    // cancel the timeout\n    clearTimeout(timeout)\n    // set the canceled flag\n    canceled = true\n    if (cleanUp) {\n      cleanUp\n    }\n  }\n}\n\n/**\n * Provides an api for getting a 2d context from a canvas element.\n *\n * The returned reference should be assigned to a canvas element. The drawing\n * method will then be called with a context on the referenced canvas.\n *\n * Be careful about defining the drawing method. If it is defined inline, then\n * it will be re-called on every render.\n *\n * ```ts\n * // defines a new drawing function on every render\n * const Component = () => {\n *   const canvasRef = useDrawingCanvas(ctx => ctx.fillRect(0, 0, 10, 10))\n *\n *   return <canvas ref={canvasRef} />\n * }\n *\n * // safer\n * const draw = ctx => ctx.fillRect(0, 0, 10, 10)\n *\n * const Component = () => {\n *   const canvasRef = useDrawingCanvas(draw)\n *\n *   return <canvas ref={canvasRef} />\n * }\n * ```\n *\n * @param draw The drawing method\n */\nexport default function useDrawingCanvas(draw: DrawingMethod) {\n  const ref = useRef<HTMLCanvasElement>()\n  const [context, setContext] = useState<CanvasRenderingContext2D>()\n  const { width, height } = useCanvasSize(ref)\n\n  useEffect(() => {\n    if (!ref.current) return\n\n    setContext(ref.current.getContext('2d') || undefined)\n  }, [ref])\n\n  useLayoutEffect(() => {\n    if (context) {\n      context.canvas.width = width\n      context.canvas.height = height\n\n      return debounceDraw(\n        () =>\n          draw(context, {\n            width,\n            height,\n            prefersReducedMotion: !window.matchMedia(\n              '(prefers-reduced-motion: no-preferece)'\n            ).matches\n          }),\n        50\n      )\n    }\n  }, [draw, context, width, height])\n\n  return ref\n}\n","import React, { MutableRefObject } from 'react'\nimport useDrawingCanvas, {\n  DrawingMethod\n} from './react-hooks-use-drawing-canvas'\nimport './Wallpaper.css'\n\nexport type CanvasDrawingMethod = DrawingMethod\n\nexport const CanvasWallpaper: React.FC<{\n  /** extra classes for css */\n  className: string\n  draw: CanvasDrawingMethod\n  /** Render the canvas pixelated; without interpolation. Default: false */\n  pixelated?: boolean\n}> = props => {\n  const { draw, className, pixelated = false } = props\n  const canvasRef = useDrawingCanvas(draw)\n  const classNames = ['Wallpaper', 'Canvas']\n\n  if (className !== undefined) {\n    classNames.push(className)\n  }\n  if (pixelated) {\n    classNames.push('pixelated')\n  }\n\n  return (\n    <canvas\n      className={classNames.join(' ')}\n      ref={canvasRef as MutableRefObject<HTMLCanvasElement>}\n    />\n  )\n}\n","export default class Cell {\n  private status: number\n  private neighbors: Cell[] = []\n\n  constructor(initiallyAlive: boolean) {\n    this.status = initiallyAlive ? 1 : 0\n  }\n\n  get isAlive() {\n    return this.status & 1\n  }\n\n  swap() {\n    this.status ^= 1\n  }\n\n  addNeighbor(neighbor: Cell) {\n    this.neighbors.push(neighbor)\n  }\n\n  check() {\n    const liveNeighbors = this.neighbors.reduce((s, n) => s + n.isAlive, 0)\n\n    if ((liveNeighbors | this.status) === 3) this.status |= 2\n  }\n\n  age() {\n    this.status = this.status >> 1\n  }\n}\n","import Cell from './Cell'\nimport { randomInt } from '../common/random'\n\nexport default class Game {\n  private width: number\n  private height: number\n  /**\n   * A cell is a number representing different states.\n   * The bits from least significan to most significant mean:\n   * - The cells current status.\n   * - The cells next status.\n   */\n  private board: Cell[][]\n\n  constructor(width: number, height: number) {\n    this.width = Math.floor(width)\n    this.height = Math.floor(height)\n    this.board = []\n\n    const probabilityOfLife = 0.1\n    for (let i = 0; i < this.width; i++) {\n      this.board[i] = []\n      for (let j = 0; j < this.height; j++) {\n        this.board[i][j] = new Cell(Math.random() < probabilityOfLife)\n      }\n    }\n\n    // addd the cell's neighbors\n    for (let i = 0; i < this.width; i++) {\n      for (let j = 0; j < this.height; j++) {\n        for (const [dx, dy] of [\n          [-1, -1],\n          [-1, 0],\n          [-1, 1],\n          [0, -1],\n          [0, 1],\n          [1, -1],\n          [1, 0],\n          [1, 1]\n        ]) {\n          const x = (i + dx + this.width) % this.width\n          const y = (j + dy + this.height) % this.height\n          this.board[i][j].addNeighbor(this.board[x][y])\n        }\n      }\n    }\n  }\n\n  draw(ctx: CanvasRenderingContext2D) {\n    for (let i = 0; i < this.width; i++) {\n      for (let j = 0; j < this.height; j++) {\n        if (this.board[i][j].isAlive) {\n          ctx.save()\n          ctx.fillStyle = `hsl(${randomInt(360)},100%,40%)`\n          ctx.fillRect(i, j, 1, 1)\n          ctx.restore()\n        }\n      }\n    }\n  }\n\n  move() {\n    this.board.forEach(row => row.forEach(cell => cell.check()))\n    this.board.forEach(row => row.forEach(cell => cell.age()))\n\n    const randomSwaps = 5\n    for (let i = 0; i < randomSwaps; i++) {\n      this.board[randomInt(this.width)][randomInt(this.height)].swap()\n    }\n  }\n}\n","import React from 'react'\nimport { CanvasWallpaper, CanvasDrawingMethod } from '../common/Wallpaper'\nimport Game from './Game'\n\nconst draw: CanvasDrawingMethod = (\n  ctx,\n  { width: widthPX, height: heightPX }\n) => {\n  // transform the canvas\n  const ratio = 4\n  const width = widthPX / ratio\n  const height = heightPX / ratio\n  ctx.setTransform(ratio, 0, 0, ratio, 0, 0)\n  ctx.globalAlpha = 0.2\n\n  const game = new Game(width, height)\n\n  const draw = () => {\n    ctx.clearRect(0, 0, width, height)\n\n    game.draw(ctx)\n    game.move()\n  }\n\n  const interval = setInterval(draw, 100)\n  return () => {\n    clearInterval(interval)\n  }\n}\n\nconst GameOfLife: React.FC = () => (\n  <CanvasWallpaper className=\"GameOfLife\" draw={draw} pixelated />\n)\n\nexport default GameOfLife\n"],"names":["randomInt","from","to","arguments","length","undefined","Math","floor","random","randomRange","useDrawingCanvas","draw","ref","useRef","context","setContext","useState","width","height","canvasRef","size","setSize","useEffect","getSize","current","dpr","window","devicePixelRatio","offsetWidth","offsetHeight","addEventListener","removeEventListener","useCanvasSize","getContext","useLayoutEffect","canvas","debounceDraw","time","cleanUp","canceled","timeout","setTimeout","async","clearTimeout","prefersReducedMotion","matchMedia","matches","CanvasWallpaper","props","className","pixelated","classNames","push","_jsx","join","Cell","constructor","initiallyAlive","status","neighbors","this","isAlive","swap","addNeighbor","neighbor","check","reduce","s","n","age","Game","board","i","j","dx","dy","x","y","ctx","save","fillStyle","fillRect","restore","move","forEach","row","cell","_ref","widthPX","heightPX","setTransform","globalAlpha","game","interval","setInterval","clearRect","clearInterval","GameOfLife"],"sourceRoot":""}